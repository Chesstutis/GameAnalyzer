package engine

import (
	"fmt"
	"log"
	"testing"
	"os"

	"github.com/notnil/chess"
	"github.com/notnil/chess/uci"
	"github.com/Chesstutis/GameAnalyzer/internal/config"
)

func TestMain(m *testing.M) {
    _, err := config.MustStockfishPath()
    if err != nil {
        fmt.Fprintln(os.Stderr, err)
        os.Exit(1) // require stockfish installed/configured
    }
    fmt.Println("Using stockfish at:", config.EnginePath)
    os.Exit(m.Run())
}
func TestParseMove_Found(t *testing.T) {
	game := chess.NewGame()
	m, err := parseMove(game.Position(), "e2e4")
	if err != nil {
		t.Fatal(err)
	}
	fmt.Printf("Move Found: %v", m)
}

func TestParseMove_NotFound(t *testing.T) {
	game := chess.NewGame()
	m, err := parseMove(game.Position(), "e7e5")
	if err != nil {
		fmt.Print("yay")
	} else {
		t.Fatalf("%v found incorrectly", m)
	}
}

func TestAnalyzePosition_Debug(t *testing.T) {
	fen := "r1bqkbnr/pppp1ppp/2n5/4N3/4P3/8/PPPP1PPP/RNBQKB1R b KQkq - 0 3"
	// fen := "r1b2r1k/4qp1p/p1n1p1p1/1p2P3/2p1N3/7R/PPB1QPPP/3R2K1 w - - 0 1"
	// fen := "8/5k2/8/4K3/4P3/8/8/8 w - - 0 1"
	fenFunc, _ := chess.FEN(fen)
	game := chess.NewGame(fenFunc)

	fmt.Println(game.Position().Board().Draw())

	e, err := AnalyzePosition(fen, "a7a6")

	if err != nil {
		log.Fatalf("Test Failed: %v", err)
	}

	fmt.Println("==== Position Analysis ====")
	fmt.Printf("Best Move: %v\nBest Move Evaluation: %v\n", e.BestMove.Move, e.BestMove.Evaluation)
	fmt.Printf("Player Move: %v\nPlayer Move Evaluation: %v\n\n", e.PlayerMove.Move, e.PlayerMove.Evaluation)
}

// Test parseMove with valid moves (using the position's own ValidMoves)
// and with clearly invalid move strings.
func TestParseMove_ValidAndInvalid(t *testing.T) {
	game := chess.NewGame()
	pos := game.Position()

	validMoves := pos.ValidMoves()
	if len(validMoves) == 0 {
		t.Fatal("no valid moves in starting position")
	}

	// pick a real valid move string generated by the library and ensure parseMove finds it
	mvStr := validMoves[0].String()
	got, err := parseMove(pos, mvStr)
	if err != nil {
		t.Fatalf("parseMove(%q) returned error: %v", mvStr, err)
	}
	if got.String() != mvStr {
		t.Fatalf("parseMove(%q) returned move %q", mvStr, got.String())
	}

	// invalid move should return an error
	_, err = parseMove(pos, "invalid-move-xyz")
	if err == nil {
		t.Fatalf("expected parseMove to error for invalid move string")
	}
}

// Tests covering CheckSolvedPos behavior for mate vs centipawn scores.
func TestCheckSolvedPos(t *testing.T) {
	t.Run("mateReported", func(t *testing.T) {
		var res uci.SearchResults
		res.Info.Score.Mate = 2 // non-zero indicates mate / solved position
		move := "e2e4"

		em := CheckSolvedPos(res, move)
		if em == nil {
			t.Fatalf("expected non-nil EvaluatedMove for mate")
		}
		if em.Move != move {
			t.Fatalf("expected Move=%q, got %q", move, em.Move)
		}
		if em.Evaluation != 1000000 {
			t.Fatalf("expected Evaluation=1000000 for mate; got %d", em.Evaluation)
		}
	})

	t.Run("centipawnScore", func(t *testing.T) {
		var res uci.SearchResults
		res.Info.Score.CP = 123
		move := "d2d4"

		em := CheckSolvedPos(res, move)
		if em == nil {
			t.Fatalf("expected non-nil EvaluatedMove for cp score")
		}
		if em.Move != move {
			t.Fatalf("expected Move=%q, got %q", move, em.Move)
		}
		if em.Evaluation != 123 {
			t.Fatalf("expected Evaluation=123; got %d", em.Evaluation)
		}
	})
}

func TestAnalyzePosition_InvalidPlayerMove_Error(t *testing.T) {
    startingFEN := "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"
    _, err := AnalyzePosition(startingFEN, "not-a-move")
    if err == nil {
        t.Fatalf("expected error for invalid player move, got nil")
    }
}
